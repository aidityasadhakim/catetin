// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addGoldenInk = `-- name: AddGoldenInk :one
UPDATE user_stats
SET golden_ink = golden_ink + $2, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

type AddGoldenInkParams struct {
	UserID    string `json:"user_id"`
	GoldenInk int32  `json:"golden_ink"`
}

func (q *Queries) AddGoldenInk(ctx context.Context, arg AddGoldenInkParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, addGoldenInk, arg.UserID, arg.GoldenInk)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const addMarble = `-- name: AddMarble :one
UPDATE user_stats
SET marble = marble + $2, updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

type AddMarbleParams struct {
	UserID string `json:"user_id"`
	Marble int32  `json:"marble"`
}

func (q *Queries) AddMarble(ctx context.Context, arg AddMarbleParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, addMarble, arg.UserID, arg.Marble)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const addSessionGoldenInk = `-- name: AddSessionGoldenInk :one
UPDATE sessions
SET 
    golden_ink_earned = golden_ink_earned + $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at
`

type AddSessionGoldenInkParams struct {
	ID              pgtype.UUID `json:"id"`
	GoldenInkEarned int32       `json:"golden_ink_earned"`
}

func (q *Queries) AddSessionGoldenInk(ctx context.Context, arg AddSessionGoldenInkParams) (Session, error) {
	row := q.db.QueryRow(ctx, addSessionGoldenInk, arg.ID, arg.GoldenInkEarned)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalMessages,
		&i.GoldenInkEarned,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addXP = `-- name: AddXP :one
UPDATE user_stats
SET 
    current_xp = current_xp + $2,
    total_xp = total_xp + $2,
    updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

type AddXPParams struct {
	UserID    string `json:"user_id"`
	CurrentXp int32  `json:"current_xp"`
}

func (q *Queries) AddXP(ctx context.Context, arg AddXPParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, addXP, arg.UserID, arg.CurrentXp)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const checkTransactionProcessed = `-- name: CheckTransactionProcessed :one
SELECT EXISTS(
    SELECT 1 FROM user_subscriptions us WHERE us.trakteer_transaction_id = $1
    UNION
    SELECT 1 FROM pending_upgrades pu WHERE pu.trakteer_transaction_id = $1
) as processed
`

func (q *Queries) CheckTransactionProcessed(ctx context.Context, trakteerTransactionID pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkTransactionProcessed, trakteerTransactionID)
	var processed bool
	err := row.Scan(&processed)
	return processed, err
}

const countMessagesBySession = `-- name: CountMessagesBySession :one
SELECT COUNT(*) FROM messages
WHERE session_id = $1
`

func (q *Queries) CountMessagesBySession(ctx context.Context, sessionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMessagesBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTodayUserMessages = `-- name: CountTodayUserMessages :one
SELECT COUNT(*)::integer FROM messages m
JOIN sessions s ON m.session_id = s.id
WHERE s.user_id = $1 
  AND m.role = 'user'
  AND s.started_at::date = CURRENT_DATE
`

func (q *Queries) CountTodayUserMessages(ctx context.Context, userID string) (int32, error) {
	row := q.db.QueryRow(ctx, countTodayUserMessages, userID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countUserMessagesBySession = `-- name: CountUserMessagesBySession :one
SELECT COUNT(*) FROM messages
WHERE session_id = $1 AND role = 'user'
`

func (q *Queries) CountUserMessagesBySession(ctx context.Context, sessionID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserMessagesBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWeekSessions = `-- name: CountWeekSessions :one
SELECT 
    COUNT(DISTINCT s.id)::integer as session_count, 
    COUNT(m.id)::integer as message_count
FROM sessions s
LEFT JOIN messages m ON m.session_id = s.id AND m.role = 'user'
WHERE s.user_id = $1
  AND s.started_at >= $2
  AND s.started_at <= $3
`

type CountWeekSessionsParams struct {
	UserID      string             `json:"user_id"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	StartedAt_2 pgtype.Timestamptz `json:"started_at_2"`
}

type CountWeekSessionsRow struct {
	SessionCount int32 `json:"session_count"`
	MessageCount int32 `json:"message_count"`
}

func (q *Queries) CountWeekSessions(ctx context.Context, arg CountWeekSessionsParams) (CountWeekSessionsRow, error) {
	row := q.db.QueryRow(ctx, countWeekSessions, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	var i CountWeekSessionsRow
	err := row.Scan(&i.SessionCount, &i.MessageCount)
	return i, err
}

const createArtwork = `-- name: CreateArtwork :one
INSERT INTO artworks (name, display_name, description, image_url, unlock_cost, reveal_cost)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, display_name, description, image_url, unlock_cost, reveal_cost, created_at
`

type CreateArtworkParams struct {
	Name        string `json:"name"`
	DisplayName string `json:"display_name"`
	Description string `json:"description"`
	ImageUrl    string `json:"image_url"`
	UnlockCost  int32  `json:"unlock_cost"`
	RevealCost  int32  `json:"reveal_cost"`
}

func (q *Queries) CreateArtwork(ctx context.Context, arg CreateArtworkParams) (Artwork, error) {
	row := q.db.QueryRow(ctx, createArtwork,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.ImageUrl,
		arg.UnlockCost,
		arg.RevealCost,
	)
	var i Artwork
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.ImageUrl,
		&i.UnlockCost,
		&i.RevealCost,
		&i.CreatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one

INSERT INTO messages (session_id, role, content)
VALUES ($1, $2, $3)
RETURNING id, session_id, role, content, created_at
`

type CreateMessageParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	Role      string      `json:"role"`
	Content   string      `json:"content"`
}

// ==================== MESSAGES ====================
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage, arg.SessionID, arg.Role, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createPendingUpgrade = `-- name: CreatePendingUpgrade :one

INSERT INTO pending_upgrades (trakteer_transaction_id, supporter_email, supporter_name, payment_amount, raw_payload, error_message)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (trakteer_transaction_id) DO NOTHING
RETURNING id, trakteer_transaction_id, supporter_email, supporter_name, payment_amount, status, resolved_at, resolved_user_id, error_message, raw_payload, created_at
`

type CreatePendingUpgradeParams struct {
	TrakteerTransactionID string      `json:"trakteer_transaction_id"`
	SupporterEmail        string      `json:"supporter_email"`
	SupporterName         string      `json:"supporter_name"`
	PaymentAmount         int32       `json:"payment_amount"`
	RawPayload            []byte      `json:"raw_payload"`
	ErrorMessage          pgtype.Text `json:"error_message"`
}

// ==================== PENDING UPGRADES ====================
func (q *Queries) CreatePendingUpgrade(ctx context.Context, arg CreatePendingUpgradeParams) (PendingUpgrade, error) {
	row := q.db.QueryRow(ctx, createPendingUpgrade,
		arg.TrakteerTransactionID,
		arg.SupporterEmail,
		arg.SupporterName,
		arg.PaymentAmount,
		arg.RawPayload,
		arg.ErrorMessage,
	)
	var i PendingUpgrade
	err := row.Scan(
		&i.ID,
		&i.TrakteerTransactionID,
		&i.SupporterEmail,
		&i.SupporterName,
		&i.PaymentAmount,
		&i.Status,
		&i.ResolvedAt,
		&i.ResolvedUserID,
		&i.ErrorMessage,
		&i.RawPayload,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO sessions (user_id)
VALUES ($1)
RETURNING id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at
`

// ==================== SESSIONS ====================
func (q *Queries) CreateSession(ctx context.Context, userID string) (Session, error) {
	row := q.db.QueryRow(ctx, createSession, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalMessages,
		&i.GoldenInkEarned,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserStats = `-- name: CreateUserStats :one
INSERT INTO user_stats (user_id)
VALUES ($1)
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

func (q *Queries) CreateUserStats(ctx context.Context, userID string) (UserStat, error) {
	row := q.db.QueryRow(ctx, createUserStats, userID)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const createUserSubscriptionAsPaid = `-- name: CreateUserSubscriptionAsPaid :one
INSERT INTO user_subscriptions (user_id, plan, upgraded_at, trakteer_transaction_id, trakteer_supporter_name, payment_amount)
VALUES ($1, 'paid', NOW(), $2, $3, $4)
ON CONFLICT (user_id) DO UPDATE SET 
    plan = 'paid',
    upgraded_at = NOW(),
    trakteer_transaction_id = EXCLUDED.trakteer_transaction_id,
    trakteer_supporter_name = EXCLUDED.trakteer_supporter_name,
    payment_amount = EXCLUDED.payment_amount,
    updated_at = NOW()
RETURNING user_id, plan, upgraded_at, trakteer_transaction_id, trakteer_supporter_name, payment_amount, created_at, updated_at
`

type CreateUserSubscriptionAsPaidParams struct {
	UserID                string      `json:"user_id"`
	TrakteerTransactionID pgtype.Text `json:"trakteer_transaction_id"`
	TrakteerSupporterName pgtype.Text `json:"trakteer_supporter_name"`
	PaymentAmount         pgtype.Int4 `json:"payment_amount"`
}

func (q *Queries) CreateUserSubscriptionAsPaid(ctx context.Context, arg CreateUserSubscriptionAsPaidParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, createUserSubscriptionAsPaid,
		arg.UserID,
		arg.TrakteerTransactionID,
		arg.TrakteerSupporterName,
		arg.PaymentAmount,
	)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.Plan,
		&i.UpgradedAt,
		&i.TrakteerTransactionID,
		&i.TrakteerSupporterName,
		&i.PaymentAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWeeklySummary = `-- name: CreateWeeklySummary :one

INSERT INTO weekly_summaries (user_id, week_start, week_end, summary, session_count, message_count, emotions)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, week_start, week_end, summary, session_count, message_count, emotions, created_at
`

type CreateWeeklySummaryParams struct {
	UserID       string      `json:"user_id"`
	WeekStart    pgtype.Date `json:"week_start"`
	WeekEnd      pgtype.Date `json:"week_end"`
	Summary      string      `json:"summary"`
	SessionCount int32       `json:"session_count"`
	MessageCount int32       `json:"message_count"`
	Emotions     []byte      `json:"emotions"`
}

// ==================== WEEKLY SUMMARIES ====================
func (q *Queries) CreateWeeklySummary(ctx context.Context, arg CreateWeeklySummaryParams) (WeeklySummary, error) {
	row := q.db.QueryRow(ctx, createWeeklySummary,
		arg.UserID,
		arg.WeekStart,
		arg.WeekEnd,
		arg.Summary,
		arg.SessionCount,
		arg.MessageCount,
		arg.Emotions,
	)
	var i WeeklySummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStart,
		&i.WeekEnd,
		&i.Summary,
		&i.SessionCount,
		&i.MessageCount,
		&i.Emotions,
		&i.CreatedAt,
	)
	return i, err
}

const endSession = `-- name: EndSession :one
UPDATE sessions
SET 
    status = $2,
    ended_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND user_id = $3
RETURNING id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at
`

type EndSessionParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
	UserID string      `json:"user_id"`
}

func (q *Queries) EndSession(ctx context.Context, arg EndSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, endSession, arg.ID, arg.Status, arg.UserID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalMessages,
		&i.GoldenInkEarned,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveSession = `-- name: GetActiveSession :one
SELECT id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at FROM sessions
WHERE user_id = $1 AND status = 'active'
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetActiveSession(ctx context.Context, userID string) (Session, error) {
	row := q.db.QueryRow(ctx, getActiveSession, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalMessages,
		&i.GoldenInkEarned,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getArtworkByID = `-- name: GetArtworkByID :one
SELECT id, name, display_name, description, image_url, unlock_cost, reveal_cost, created_at FROM artworks
WHERE id = $1
`

func (q *Queries) GetArtworkByID(ctx context.Context, id pgtype.UUID) (Artwork, error) {
	row := q.db.QueryRow(ctx, getArtworkByID, id)
	var i Artwork
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.ImageUrl,
		&i.UnlockCost,
		&i.RevealCost,
		&i.CreatedAt,
	)
	return i, err
}

const getArtworkByName = `-- name: GetArtworkByName :one
SELECT id, name, display_name, description, image_url, unlock_cost, reveal_cost, created_at FROM artworks
WHERE name = $1
`

func (q *Queries) GetArtworkByName(ctx context.Context, name string) (Artwork, error) {
	row := q.db.QueryRow(ctx, getArtworkByName, name)
	var i Artwork
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.ImageUrl,
		&i.UnlockCost,
		&i.RevealCost,
		&i.CreatedAt,
	)
	return i, err
}

const getCurrentArtwork = `-- name: GetCurrentArtwork :one
SELECT 
    ua.id, ua.user_id, ua.artwork_id, ua.progress, ua.status, ua.unlocked_at, ua.completed_at, ua.created_at, ua.updated_at,
    a.name,
    a.display_name,
    a.description,
    a.image_url,
    a.unlock_cost,
    a.reveal_cost
FROM user_artworks ua
JOIN artworks a ON ua.artwork_id = a.id
WHERE ua.user_id = $1 AND ua.status = 'in_progress'
ORDER BY ua.unlocked_at DESC
LIMIT 1
`

type GetCurrentArtworkRow struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      string             `json:"user_id"`
	ArtworkID   pgtype.UUID        `json:"artwork_id"`
	Progress    int32              `json:"progress"`
	Status      string             `json:"status"`
	UnlockedAt  pgtype.Timestamptz `json:"unlocked_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Name        string             `json:"name"`
	DisplayName string             `json:"display_name"`
	Description string             `json:"description"`
	ImageUrl    string             `json:"image_url"`
	UnlockCost  int32              `json:"unlock_cost"`
	RevealCost  int32              `json:"reveal_cost"`
}

func (q *Queries) GetCurrentArtwork(ctx context.Context, userID string) (GetCurrentArtworkRow, error) {
	row := q.db.QueryRow(ctx, getCurrentArtwork, userID)
	var i GetCurrentArtworkRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ArtworkID,
		&i.Progress,
		&i.Status,
		&i.UnlockedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.ImageUrl,
		&i.UnlockCost,
		&i.RevealCost,
	)
	return i, err
}

const getLatestWeeklySummary = `-- name: GetLatestWeeklySummary :one
SELECT id, user_id, week_start, week_end, summary, session_count, message_count, emotions, created_at FROM weekly_summaries
WHERE user_id = $1
ORDER BY week_start DESC
LIMIT 1
`

func (q *Queries) GetLatestWeeklySummary(ctx context.Context, userID string) (WeeklySummary, error) {
	row := q.db.QueryRow(ctx, getLatestWeeklySummary, userID)
	var i WeeklySummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStart,
		&i.WeekEnd,
		&i.Summary,
		&i.SessionCount,
		&i.MessageCount,
		&i.Emotions,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingUpgrade = `-- name: GetPendingUpgrade :one
SELECT id, trakteer_transaction_id, supporter_email, supporter_name, payment_amount, status, resolved_at, resolved_user_id, error_message, raw_payload, created_at FROM pending_upgrades WHERE id = $1
`

func (q *Queries) GetPendingUpgrade(ctx context.Context, id pgtype.UUID) (PendingUpgrade, error) {
	row := q.db.QueryRow(ctx, getPendingUpgrade, id)
	var i PendingUpgrade
	err := row.Scan(
		&i.ID,
		&i.TrakteerTransactionID,
		&i.SupporterEmail,
		&i.SupporterName,
		&i.PaymentAmount,
		&i.Status,
		&i.ResolvedAt,
		&i.ResolvedUserID,
		&i.ErrorMessage,
		&i.RawPayload,
		&i.CreatedAt,
	)
	return i, err
}

const getRecentMessages = `-- name: GetRecentMessages :many
SELECT id, session_id, role, content, created_at FROM messages
WHERE session_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentMessagesParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) GetRecentMessages(ctx context.Context, arg GetRecentMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getRecentMessages, arg.SessionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at FROM sessions
WHERE id = $1 AND user_id = $2
`

type GetSessionByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) GetSessionByID(ctx context.Context, arg GetSessionByIDParams) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByID, arg.ID, arg.UserID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalMessages,
		&i.GoldenInkEarned,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTodayActiveSession = `-- name: GetTodayActiveSession :one
SELECT id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at FROM sessions
WHERE user_id = $1 
  AND status = 'active' 
  AND started_at::date = CURRENT_DATE
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetTodayActiveSession(ctx context.Context, userID string) (Session, error) {
	row := q.db.QueryRow(ctx, getTodayActiveSession, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalMessages,
		&i.GoldenInkEarned,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserArtwork = `-- name: GetUserArtwork :one

SELECT id, user_id, artwork_id, progress, status, unlocked_at, completed_at, created_at, updated_at FROM user_artworks
WHERE user_id = $1 AND artwork_id = $2
`

type GetUserArtworkParams struct {
	UserID    string      `json:"user_id"`
	ArtworkID pgtype.UUID `json:"artwork_id"`
}

// ==================== USER ARTWORKS ====================
func (q *Queries) GetUserArtwork(ctx context.Context, arg GetUserArtworkParams) (UserArtwork, error) {
	row := q.db.QueryRow(ctx, getUserArtwork, arg.UserID, arg.ArtworkID)
	var i UserArtwork
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ArtworkID,
		&i.Progress,
		&i.Status,
		&i.UnlockedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserLevel = `-- name: GetUserLevel :one
SELECT level, current_xp, total_xp FROM user_stats
WHERE user_id = $1
`

type GetUserLevelRow struct {
	Level     int32 `json:"level"`
	CurrentXp int32 `json:"current_xp"`
	TotalXp   int32 `json:"total_xp"`
}

func (q *Queries) GetUserLevel(ctx context.Context, userID string) (GetUserLevelRow, error) {
	row := q.db.QueryRow(ctx, getUserLevel, userID)
	var i GetUserLevelRow
	err := row.Scan(&i.Level, &i.CurrentXp, &i.TotalXp)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one

SELECT user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp FROM user_stats WHERE user_id = $1
`

// ==================== USER STATS ====================
func (q *Queries) GetUserStats(ctx context.Context, userID string) (UserStat, error) {
	row := q.db.QueryRow(ctx, getUserStats, userID)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const getUserSubscription = `-- name: GetUserSubscription :one

SELECT user_id, plan, upgraded_at, trakteer_transaction_id, trakteer_supporter_name, payment_amount, created_at, updated_at FROM user_subscriptions WHERE user_id = $1
`

// ==================== USER SUBSCRIPTIONS ====================
func (q *Queries) GetUserSubscription(ctx context.Context, userID string) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, getUserSubscription, userID)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.Plan,
		&i.UpgradedAt,
		&i.TrakteerTransactionID,
		&i.TrakteerSupporterName,
		&i.PaymentAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWeekMessages = `-- name: GetWeekMessages :many
SELECT m.content, m.created_at, s.started_at
FROM messages m
JOIN sessions s ON m.session_id = s.id
WHERE s.user_id = $1
  AND m.role = 'user'
  AND s.started_at >= $2
  AND s.started_at <= $3
ORDER BY m.created_at ASC
`

type GetWeekMessagesParams struct {
	UserID      string             `json:"user_id"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	StartedAt_2 pgtype.Timestamptz `json:"started_at_2"`
}

type GetWeekMessagesRow struct {
	Content   string             `json:"content"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
}

func (q *Queries) GetWeekMessages(ctx context.Context, arg GetWeekMessagesParams) ([]GetWeekMessagesRow, error) {
	rows, err := q.db.Query(ctx, getWeekMessages, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeekMessagesRow{}
	for rows.Next() {
		var i GetWeekMessagesRow
		if err := rows.Scan(&i.Content, &i.CreatedAt, &i.StartedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklySummary = `-- name: GetWeeklySummary :one
SELECT id, user_id, week_start, week_end, summary, session_count, message_count, emotions, created_at FROM weekly_summaries
WHERE user_id = $1 AND week_start = $2
`

type GetWeeklySummaryParams struct {
	UserID    string      `json:"user_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) GetWeeklySummary(ctx context.Context, arg GetWeeklySummaryParams) (WeeklySummary, error) {
	row := q.db.QueryRow(ctx, getWeeklySummary, arg.UserID, arg.WeekStart)
	var i WeeklySummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStart,
		&i.WeekEnd,
		&i.Summary,
		&i.SessionCount,
		&i.MessageCount,
		&i.Emotions,
		&i.CreatedAt,
	)
	return i, err
}

const incrementSessionMessages = `-- name: IncrementSessionMessages :one
UPDATE sessions
SET 
    total_messages = total_messages + 1,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at
`

func (q *Queries) IncrementSessionMessages(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, incrementSessionMessages, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.TotalMessages,
		&i.GoldenInkEarned,
		&i.StartedAt,
		&i.EndedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listArtworks = `-- name: ListArtworks :many

SELECT id, name, display_name, description, image_url, unlock_cost, reveal_cost, created_at FROM artworks
ORDER BY unlock_cost ASC
`

// ==================== ARTWORKS ====================
func (q *Queries) ListArtworks(ctx context.Context) ([]Artwork, error) {
	rows, err := q.db.Query(ctx, listArtworks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Artwork{}
	for rows.Next() {
		var i Artwork
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.ImageUrl,
			&i.UnlockCost,
			&i.RevealCost,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesBySession = `-- name: ListMessagesBySession :many
SELECT id, session_id, role, content, created_at FROM messages
WHERE session_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListMessagesBySession(ctx context.Context, sessionID pgtype.UUID) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingUpgrades = `-- name: ListPendingUpgrades :many
SELECT id, trakteer_transaction_id, supporter_email, supporter_name, payment_amount, status, resolved_at, resolved_user_id, error_message, raw_payload, created_at FROM pending_upgrades 
WHERE status = 'pending'
ORDER BY created_at DESC
`

func (q *Queries) ListPendingUpgrades(ctx context.Context) ([]PendingUpgrade, error) {
	rows, err := q.db.Query(ctx, listPendingUpgrades)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PendingUpgrade{}
	for rows.Next() {
		var i PendingUpgrade
		if err := rows.Scan(
			&i.ID,
			&i.TrakteerTransactionID,
			&i.SupporterEmail,
			&i.SupporterName,
			&i.PaymentAmount,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedUserID,
			&i.ErrorMessage,
			&i.RawPayload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByUser = `-- name: ListSessionsByUser :many
SELECT id, user_id, status, total_messages, golden_ink_earned, started_at, ended_at, created_at, updated_at FROM sessions
WHERE user_id = $1
ORDER BY started_at DESC
LIMIT $2 OFFSET $3
`

type ListSessionsByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListSessionsByUser(ctx context.Context, arg ListSessionsByUserParams) ([]Session, error) {
	rows, err := q.db.Query(ctx, listSessionsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalMessages,
			&i.GoldenInkEarned,
			&i.StartedAt,
			&i.EndedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsWithPreview = `-- name: ListSessionsWithPreview :many
SELECT 
    s.id, s.user_id, s.status, s.total_messages, s.golden_ink_earned, s.started_at, s.ended_at, s.created_at, s.updated_at,
    COALESCE(
        (SELECT LEFT(m.content, 150)
         FROM messages m 
         WHERE m.session_id = s.id AND m.role = 'user' 
         ORDER BY m.created_at ASC 
         LIMIT 1),
        ''
    ) as first_user_message
FROM sessions s
WHERE s.user_id = $1
ORDER BY s.started_at DESC
LIMIT $2 OFFSET $3
`

type ListSessionsWithPreviewParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListSessionsWithPreviewRow struct {
	ID               pgtype.UUID        `json:"id"`
	UserID           string             `json:"user_id"`
	Status           string             `json:"status"`
	TotalMessages    int32              `json:"total_messages"`
	GoldenInkEarned  int32              `json:"golden_ink_earned"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	EndedAt          pgtype.Timestamptz `json:"ended_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	FirstUserMessage interface{}        `json:"first_user_message"`
}

func (q *Queries) ListSessionsWithPreview(ctx context.Context, arg ListSessionsWithPreviewParams) ([]ListSessionsWithPreviewRow, error) {
	rows, err := q.db.Query(ctx, listSessionsWithPreview, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsWithPreviewRow{}
	for rows.Next() {
		var i ListSessionsWithPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.TotalMessages,
			&i.GoldenInkEarned,
			&i.StartedAt,
			&i.EndedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstUserMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserArtworks = `-- name: ListUserArtworks :many
SELECT 
    ua.id, ua.user_id, ua.artwork_id, ua.progress, ua.status, ua.unlocked_at, ua.completed_at, ua.created_at, ua.updated_at,
    a.name,
    a.display_name,
    a.description,
    a.image_url,
    a.unlock_cost,
    a.reveal_cost
FROM user_artworks ua
JOIN artworks a ON ua.artwork_id = a.id
WHERE ua.user_id = $1
ORDER BY ua.created_at DESC
`

type ListUserArtworksRow struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      string             `json:"user_id"`
	ArtworkID   pgtype.UUID        `json:"artwork_id"`
	Progress    int32              `json:"progress"`
	Status      string             `json:"status"`
	UnlockedAt  pgtype.Timestamptz `json:"unlocked_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Name        string             `json:"name"`
	DisplayName string             `json:"display_name"`
	Description string             `json:"description"`
	ImageUrl    string             `json:"image_url"`
	UnlockCost  int32              `json:"unlock_cost"`
	RevealCost  int32              `json:"reveal_cost"`
}

func (q *Queries) ListUserArtworks(ctx context.Context, userID string) ([]ListUserArtworksRow, error) {
	rows, err := q.db.Query(ctx, listUserArtworks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserArtworksRow{}
	for rows.Next() {
		var i ListUserArtworksRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ArtworkID,
			&i.Progress,
			&i.Status,
			&i.UnlockedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.ImageUrl,
			&i.UnlockCost,
			&i.RevealCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWeeklySummaries = `-- name: ListWeeklySummaries :many
SELECT id, user_id, week_start, week_end, summary, session_count, message_count, emotions, created_at FROM weekly_summaries
WHERE user_id = $1
ORDER BY week_start DESC
LIMIT $2 OFFSET $3
`

type ListWeeklySummariesParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListWeeklySummaries(ctx context.Context, arg ListWeeklySummariesParams) ([]WeeklySummary, error) {
	rows, err := q.db.Query(ctx, listWeeklySummaries, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WeeklySummary{}
	for rows.Next() {
		var i WeeklySummary
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WeekStart,
			&i.WeekEnd,
			&i.Summary,
			&i.SessionCount,
			&i.MessageCount,
			&i.Emotions,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolvePendingUpgrade = `-- name: ResolvePendingUpgrade :one
UPDATE pending_upgrades
SET status = 'resolved', resolved_at = NOW(), resolved_user_id = $2
WHERE id = $1
RETURNING id, trakteer_transaction_id, supporter_email, supporter_name, payment_amount, status, resolved_at, resolved_user_id, error_message, raw_payload, created_at
`

type ResolvePendingUpgradeParams struct {
	ID             pgtype.UUID `json:"id"`
	ResolvedUserID pgtype.Text `json:"resolved_user_id"`
}

func (q *Queries) ResolvePendingUpgrade(ctx context.Context, arg ResolvePendingUpgradeParams) (PendingUpgrade, error) {
	row := q.db.QueryRow(ctx, resolvePendingUpgrade, arg.ID, arg.ResolvedUserID)
	var i PendingUpgrade
	err := row.Scan(
		&i.ID,
		&i.TrakteerTransactionID,
		&i.SupporterEmail,
		&i.SupporterName,
		&i.PaymentAmount,
		&i.Status,
		&i.ResolvedAt,
		&i.ResolvedUserID,
		&i.ErrorMessage,
		&i.RawPayload,
		&i.CreatedAt,
	)
	return i, err
}

const spendGoldenInk = `-- name: SpendGoldenInk :one
UPDATE user_stats
SET golden_ink = golden_ink - $2, updated_at = NOW()
WHERE user_id = $1 AND golden_ink >= $2
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

type SpendGoldenInkParams struct {
	UserID    string `json:"user_id"`
	GoldenInk int32  `json:"golden_ink"`
}

func (q *Queries) SpendGoldenInk(ctx context.Context, arg SpendGoldenInkParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, spendGoldenInk, arg.UserID, arg.GoldenInk)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const spendMarble = `-- name: SpendMarble :one
UPDATE user_stats
SET marble = marble - $2, updated_at = NOW()
WHERE user_id = $1 AND marble >= $2
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

type SpendMarbleParams struct {
	UserID string `json:"user_id"`
	Marble int32  `json:"marble"`
}

func (q *Queries) SpendMarble(ctx context.Context, arg SpendMarbleParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, spendMarble, arg.UserID, arg.Marble)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const unlockArtwork = `-- name: UnlockArtwork :one
INSERT INTO user_artworks (user_id, artwork_id, status, unlocked_at)
VALUES ($1, $2, 'in_progress', NOW())
RETURNING id, user_id, artwork_id, progress, status, unlocked_at, completed_at, created_at, updated_at
`

type UnlockArtworkParams struct {
	UserID    string      `json:"user_id"`
	ArtworkID pgtype.UUID `json:"artwork_id"`
}

func (q *Queries) UnlockArtwork(ctx context.Context, arg UnlockArtworkParams) (UserArtwork, error) {
	row := q.db.QueryRow(ctx, unlockArtwork, arg.UserID, arg.ArtworkID)
	var i UserArtwork
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ArtworkID,
		&i.Progress,
		&i.Status,
		&i.UnlockedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateArtworkProgress = `-- name: UpdateArtworkProgress :one
UPDATE user_artworks
SET 
    progress = $3,
    status = CASE WHEN $3 >= 100 THEN 'completed' ELSE status END,
    completed_at = CASE WHEN $3 >= 100 THEN NOW() ELSE completed_at END,
    updated_at = NOW()
WHERE user_id = $1 AND artwork_id = $2
RETURNING id, user_id, artwork_id, progress, status, unlocked_at, completed_at, created_at, updated_at
`

type UpdateArtworkProgressParams struct {
	UserID    string      `json:"user_id"`
	ArtworkID pgtype.UUID `json:"artwork_id"`
	Progress  int32       `json:"progress"`
}

func (q *Queries) UpdateArtworkProgress(ctx context.Context, arg UpdateArtworkProgressParams) (UserArtwork, error) {
	row := q.db.QueryRow(ctx, updateArtworkProgress, arg.UserID, arg.ArtworkID, arg.Progress)
	var i UserArtwork
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ArtworkID,
		&i.Progress,
		&i.Status,
		&i.UnlockedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLevel = `-- name: UpdateLevel :one
UPDATE user_stats
SET 
    level = $2,
    current_xp = $3,
    updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

type UpdateLevelParams struct {
	UserID    string `json:"user_id"`
	Level     int32  `json:"level"`
	CurrentXp int32  `json:"current_xp"`
}

func (q *Queries) UpdateLevel(ctx context.Context, arg UpdateLevelParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, updateLevel, arg.UserID, arg.Level, arg.CurrentXp)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const updateStreak = `-- name: UpdateStreak :one
UPDATE user_stats
SET 
    current_streak = $2,
    longest_streak = GREATEST(longest_streak, $2),
    last_active_date = $3,
    updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

type UpdateStreakParams struct {
	UserID         string      `json:"user_id"`
	CurrentStreak  int32       `json:"current_streak"`
	LastActiveDate pgtype.Date `json:"last_active_date"`
}

func (q *Queries) UpdateStreak(ctx context.Context, arg UpdateStreakParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, updateStreak, arg.UserID, arg.CurrentStreak, arg.LastActiveDate)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const upgradeUserToPaid = `-- name: UpgradeUserToPaid :one
UPDATE user_subscriptions
SET 
    plan = 'paid',
    upgraded_at = NOW(),
    trakteer_transaction_id = $2,
    trakteer_supporter_name = $3,
    payment_amount = $4,
    updated_at = NOW()
WHERE user_id = $1
RETURNING user_id, plan, upgraded_at, trakteer_transaction_id, trakteer_supporter_name, payment_amount, created_at, updated_at
`

type UpgradeUserToPaidParams struct {
	UserID                string      `json:"user_id"`
	TrakteerTransactionID pgtype.Text `json:"trakteer_transaction_id"`
	TrakteerSupporterName pgtype.Text `json:"trakteer_supporter_name"`
	PaymentAmount         pgtype.Int4 `json:"payment_amount"`
}

func (q *Queries) UpgradeUserToPaid(ctx context.Context, arg UpgradeUserToPaidParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, upgradeUserToPaid,
		arg.UserID,
		arg.TrakteerTransactionID,
		arg.TrakteerSupporterName,
		arg.PaymentAmount,
	)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.Plan,
		&i.UpgradedAt,
		&i.TrakteerTransactionID,
		&i.TrakteerSupporterName,
		&i.PaymentAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserStats = `-- name: UpsertUserStats :one
INSERT INTO user_stats (user_id)
VALUES ($1)
ON CONFLICT (user_id) DO UPDATE SET updated_at = NOW()
RETURNING user_id, golden_ink, marble, current_streak, longest_streak, last_active_date, created_at, updated_at, level, current_xp, total_xp
`

func (q *Queries) UpsertUserStats(ctx context.Context, userID string) (UserStat, error) {
	row := q.db.QueryRow(ctx, upsertUserStats, userID)
	var i UserStat
	err := row.Scan(
		&i.UserID,
		&i.GoldenInk,
		&i.Marble,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActiveDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Level,
		&i.CurrentXp,
		&i.TotalXp,
	)
	return i, err
}

const upsertUserSubscription = `-- name: UpsertUserSubscription :one
INSERT INTO user_subscriptions (user_id, plan)
VALUES ($1, 'free')
ON CONFLICT (user_id) DO UPDATE SET updated_at = NOW()
RETURNING user_id, plan, upgraded_at, trakteer_transaction_id, trakteer_supporter_name, payment_amount, created_at, updated_at
`

func (q *Queries) UpsertUserSubscription(ctx context.Context, userID string) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, upsertUserSubscription, userID)
	var i UserSubscription
	err := row.Scan(
		&i.UserID,
		&i.Plan,
		&i.UpgradedAt,
		&i.TrakteerTransactionID,
		&i.TrakteerSupporterName,
		&i.PaymentAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
